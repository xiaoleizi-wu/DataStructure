### 赫夫曼树

> 我们把两棵二叉树简化成叶子结点带权的二叉树权（注意：树结点间的连线相关的树叫权，weight）

##### huffman树：先找出两个最小的结点，然后构成一个新的结点，以此类推。。。

##### 路径：是指树中的一个结点到另一个结点的分支所构成的路线；

##### 结点的路径长度
> 从根结点到该结点的路径上的连接数；

##### 树的路径长度
> 树中的每个叶子的结点的路径长度之和；

##### 结点带权路径长度
> 结点的路劲长度与结点权值的乘积；

##### 树的带权路径长度：
> WPL（Weighted Path Length）是树中所有叶子结点的带权路径长度之和；
> 

￼![] (https://github.com/xiaoleizi-wu/DataStructure/blob/master/list_src/huffman.png?raw=true)

	WPL1 = 5 * 1 + 15 * 2 + 70 * 3 + 3 * 10；
	WPL2 = 10 * 1 + 70 * 2 + 5 * 3 + 15 * 3；
	WPL越小，说明构造出来的二叉树性能越优；

##### 问题：构造最优的赫夫曼二叉树

赫夫曼编码可以有效的压缩数据（通常可以有效的节省20% ~ 90%的空间，具体压缩率依赖于数据的特性）

	特定名词：定长编码，变长编码，前缀码；
	定长编码：像ASCII编码；
	变长编码：单个编码不一致，可以根据整体出现频率来调节；
	    前缀码：任意一个字符的编码都不是另一个字符编码的前缀；
	haffman编码: 左子树都用0表示， 右子树都用1表示； 

##### Huffman编码

> 一般的，设需要编码的字符集为{d1,d2, d3...dn},各个字符在电文中出现的此时频率集合为{w1，w2,...wn}, 以d1,d2, d3...dn为叶子结点，以w1，w2,...wn对应的叶子结点的权值构造一棵Huffman树。Huffman树是以左分支代表0，右分支代表1，从根结点到叶子结点进过的结点的路径组成的0和1序列对应的字符编码。

##### build a priority queue
> 优先级是从小到大排序的，即出现的频率次数多的，排序在前面（权值就是字符出现的次数，> 路径的长度即每个字符编码的长度，出现次数越多，即编码长度越短）； 

build a haffmanTree

build a haffmanTable 
#### 储存字符串
#### encode编码  
再一次来遍历要压缩的文件，找到table对应的的code 
#### decode解码 
将字符串再匹配成树

##### Huffman 树特点是：
1. 权值越大的结点，离根结点越近；
2. 树中没有度为1的结点，这类树叫做正则（严格）二叉树
3. 树的带权路径最短
